{"ts":1361251896615,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\n *  Dracula Graph Layout and Drawing Framework 0.0.3alpha\n *  (c) 2010 Philipp Strathausen <strathausen@gmail.com>, http://strathausen.eu\n *  Contributions by Jake Stothard <stothardj@gmail.com>.\n *\n *  based on the Graph JavaScript framework, version 0.0.1\n *  (c) 2006 Aslak Hellesoy <aslak.hellesoy@gmail.com>\n *  (c) 2006 Dave Hoover <dave.hoover@gmail.com>\n *\n *  Ported from Graph::Layouter::Spring in\n *    http://search.cpan.org/~pasky/Graph-Layderer-0.02/\n *  The algorithm is based on a spring-style layouter of a Java-based social\n *  network tracker PieSpy written by Paul Mutton <paul@jibble.org>.\n *\n *  This code is freely distributable under the MIT license. Commercial use is\n *  hereby granted without any cost or restriction.\n *\n *  Links:\n *\n *  Graph Dracula JavaScript Framework:\n *      http://graphdracula.net\n *\n /*--------------------------------------------------------------------------*/\n\n\n\n/*\n * Graph\n */\nvar Graph = function() {\n  this.nodes = {};\n  this.edges = [];\n  this.snapshots = []; // previous graph states TODO to be implemented\n};\nGraph.prototype = {\n  /*\n   * add a node\n   * @id          the node's ID (string or number)\n   * @content     (optional, dictionary) can contain any information that is\n   *              being interpreted by the layout algorithm or the graph\n   *              representation\n   */\n  addNode: function(id, content) {\n    /* testing if node is already existing in the graph */\n    if(this.nodes[id] === undefined) {\n      this.nodes[id] = new Graph.Node(id, content);\n    }\n    return this.nodes[id];\n  },\n\n  addEdge: function(source, target, style) {\n    var s = this.addNode(source);\n    var t = this.addNode(target);\n    var edge = new Graph.Edge({ source: s, target: t, style: style });\n    s.edges.push(edge);\n    this.edges.push(edge);\n    // NOTE: Even directed edges are added to both nodes.\n    t.edges.push(edge);\n  },\n\n  /* TODO to be implemented\n   * Preserve a copy of the graph state (nodes, positions, ...)\n   * @comment     a comment describing the state\n   */\n  snapShot: function(comment) {\n    // FIXME\n    //var graph = new Graph();\n    //graph.nodes = jQuery.extend(true, {}, this.nodes);\n    //graph.edges = jQuery.extend(true, {}, this.edges);\n    //this.snapshots.push({comment: comment, graph: graph});\n  },\n  removeNode: function(id) {\n    delete this.nodes[id];\n    for(var i = 0; i < this.edges.length; i++) {\n      if (this.edges[i].source.id == id || this.edges[i].target.id == id) {\n        this.edges.splice(i, 1);\n        i--;\n      }\n    }\n  }\n};\n\n/*\n * Edge\n */\nGraph.Edge = function DraculaEdge(opts) {\n  this.source = opts.source;\n  this.target = opts.target;\n  this.style = { directed: false };\n  if (opts.style) {\n    this.style = jQuery.extend(true, this.style, opts.style);\n  }\n};\nGraph.Edge.prototype = {\n  weight: 0,\n  hide: function hideEdge() {\n    this.connection.fg.hide();\n    this.connection.bg && this.bg.connection.hide();\n  }\n}\n\n/*\n * Node\n */\nGraph.Node = function DraculaNode(id, node){\n  node = node || {};\n  node.id = id;\n  node.edges = [];\n  node.hide = function() {\n    this.hidden = true;\n    this.shape && this.shape.hide(); /* FIXME this is representation specific code and should be elsewhere */\n    for(i in this.edges)\n      (this.edges[i].source.id == id || this.edges[i].target == id) && this.edges[i].hide && this.edges[i].hide();\n  };\n  node.show = function() {\n    this.hidden = false;\n    this.shape && this.shape.show();\n    for(i in this.edges)\n      (this.edges[i].source.id == id || this.edges[i].target == id) && this.edges[i].show && this.edges[i].show();\n  };\n  return node;\n};\nGraph.Node.prototype = {\n};\n\n/*\n * Renderer Base Class\n */\nGraph.Renderer = {};\n\n/*\n * Renderer implementation using RaphaelJS\n */\nGraph.Renderer.Raphael = function(element, graph, width, height) {\n  this.width = width || 400;\n  this.height = height || 400;\n  this.r = Raphael(element, this.width, this.height);\n  this.radius = 40; /* max dimension of a node */\n  this.graph = graph;\n  this.mouse_in = false;\n\n  /* TODO default node rendering function */\n  if(!this.graph.render) {\n    this.graph.render = function() {\n      return;\n    }\n  }\n  this.draw();\n};\n\n\n/* Moved this default node renderer function out of the main prototype code\n * so it can be override by default */\nGraph.Renderer.defaultRenderFunc = function(r, node) {\n  /* the default node drawing */\n  var color = Raphael.getColor();\n  var ellipse = r.ellipse(0, 0, 30, 20).attr({\n    fill: node.fill || color,\n    stroke: node.stroke || color,\n    \"stroke-width\": 2\n  });\n  /* set DOM node ID */\n  ellipse.node.id = node.label || node.id;\n  shape = r.set().push(ellipse).push(r.text(0, 30, node.label || node.id));\n  return shape;\n}\n\n\nGraph.Renderer.Raphael.prototype = {\n  translate: function(point) {\n    return [\n      (point[0] - this.graph.layoutMinX) * this.factorX + this.radius,\n      (point[1] - this.graph.layoutMinY) * this.factorY + this.radius\n    ];\n  },\n\n  rotate: function(point, length, angle) {\n    var dx = length * Math.cos(angle);\n    var dy = length * Math.sin(angle);\n    return [point[0]+dx, point[1]+dy];\n  },\n\n  draw: function() {\n    this.factorX = (this.width - 2 * this.radius) / (this.graph.layoutMaxX - this.graph.layoutMinX);\n    this.factorY = (this.height - 2 * this.radius) / (this.graph.layoutMaxY - this.graph.layoutMinY);\n    for (i in this.graph.nodes) {\n      this.drawNode(this.graph.nodes[i]);\n    }\n    for (var i = 0; i < this.graph.edges.length; i++) {\n      this.drawEdge(this.graph.edges[i]);\n    }\n  },\n\n  drawNode: function(node) {\n    var point = this.translate([node.layoutPosX, node.layoutPosY]);\n    node.point = point;\n    var r = this.r;\n    var graph = this.graph;\n\n    /* if node has already been drawn, move the nodes */\n    if(node.shape) {\n      var oBBox = node.shape.getBBox();\n      var opoint = { x: oBBox.x + oBBox.width / 2, y: oBBox.y + oBBox.height / 2};\n      node.shape.translate(Math.round(point[0] - opoint.x), Math.round(point[1] - opoint.y));\n      this.r.safari();\n      return node;\n    }/* else, draw new nodes */\n\n    var shape;\n\n    /* if a node renderer function is provided by the user, then use it\n       or the default render function instead */\n    if(!node.render) {\n      node.render = Graph.Renderer.defaultRenderFunc;\n    }\n    /* or check for an ajax representation of the nodes */\n    if(node.shapes) {\n      // TODO ajax representation evaluation\n    }\n\n    var selfRef = this;\n    shape = node.render(this.r, node).hide();\n\n    shape.attr({\"fill-opacity\": .6});\n    /* re-reference to the node an element belongs to, needed for dragging all elements of a node */\n    shape.items.forEach(function(item) {\n      item.set = shape;\n      item.node.style.cursor = \"move\";\n    });\n    shape.drag(\n      function dragMove(dx, dy, x, y) {\n        var dx = this.set.ox;\n        var dy = this.set.oy;\n        var bBox = this.set.getBBox();\n        var newX = x - dx + (bBox.x + bBox.width / 2);\n        var newY = y - dy + (bBox.y + bBox.height / 2);\n        var clientX =\n          x - (newX < 20 ? newX - 20 : newX > r.width - 20 ? newX - r.width + 20 : 0);\n        var clientY =\n          y - (newY < 20 ? newY - 20 : newY > r.height - 20 ? newY - r.height + 20 : 0);\n        this.set.translate(clientX - Math.round(dx), clientY - Math.round(dy));\n        for (var i in selfRef.graph.edges) {\n          selfRef.graph.edges[i] &&\n            selfRef.graph.edges[i].connection && selfRef.graph.edges[i].connection.draw();\n        }\n        r.safari();\n        this.set.ox = clientX;\n        this.set.oy = clientY;\n      },\n      function dragEnter(x, y) {\n        this.set.ox = x;\n        this.set.oy = y;\n        this.animate({\"fill-opacity\": .2}, 500);\n      },\n      function dragOut() {\n        this.animate({\"fill-opacity\": .6}, 500);\n      }\n    );\n\n    var box = shape.getBBox();\n    shape.translate(Math.round(point[0]-(box.x+box.width/2)),Math.round(point[1]-(box.y+box.height/2)))\n    //console.log(box,point);\n    node.hidden || shape.show();\n    node.shape = shape;\n  },\n  drawEdge: function(edge) {\n    /* if this edge already exists the other way around and is undirected */\n    if(edge.backedge)\n      return;\n    if(edge.source.hidden || edge.target.hidden) {\n      edge.connection && edge.connection.fg.hide();\n      edge.connection.bg && edge.connection.bg.hide();\n      return;\n    }\n    /* if edge already has been drawn, only refresh the edge */\n    if(!edge.connection) {\n      edge.style && edge.style.callback && edge.style.callback(edge); // TODO move this somewhere else\n      edge.connection = this.r.connection(edge.source.shape, edge.target.shape, edge.style);\n      return;\n    }\n    //FIXME showing doesn't work well\n    edge.connection.fg.show();\n    edge.connection.bg && edge.connection.bg.show();\n    edge.connection.draw();\n  }\n};\nGraph.Layout = {};\nGraph.Layout.Spring = function(graph) {\n    this.graph = graph;\n    this.iterations = 500;\n    this.maxRepulsiveForceDistance = 6;\n    this.k = 2;\n    this.c = 0.01;\n    this.maxVertexMovement = 0.5;\n    this.layout();\n};\nGraph.Layout.Spring.prototype = {\n    layout: function() {\n        this.layoutPrepare();\n        for (var i = 0; i < this.iterations; i++) {\n            this.layoutIteration();\n        }\n        this.layoutCalcBounds();\n    },\n\n    layoutPrepare: function() {\n        for (i in this.graph.nodes) {\n            var node = this.graph.nodes[i];\n            node.layoutPosX = 0;\n            node.layoutPosY = 0;\n            node.layoutForceX = 0;\n            node.layoutForceY = 0;\n        }\n\n    },\n\n    layoutCalcBounds: function() {\n        var minx = Infinity, maxx = -Infinity, miny = Infinity, maxy = -Infinity;\n\n        for (i in this.graph.nodes) {\n            var x = this.graph.nodes[i].layoutPosX;\n            var y = this.graph.nodes[i].layoutPosY;\n\n            if(x > maxx) maxx = x;\n            if(x < minx) minx = x;\n            if(y > maxy) maxy = y;\n            if(y < miny) miny = y;\n        }\n\n        this.graph.layoutMinX = minx;\n        this.graph.layoutMaxX = maxx;\n        this.graph.layoutMinY = miny;\n        this.graph.layoutMaxY = maxy;\n    },\n\n    layoutIteration: function() {\n        // Forces on nodes due to node-node repulsions\n\n        var prev = new Array();\n        for(var c in this.graph.nodes) {\n            var node1 = this.graph.nodes[c];\n            for (var d in prev) {\n                var node2 = this.graph.nodes[prev[d]];\n                this.layoutRepulsive(node1, node2);\n\n            }\n            prev.push(c);\n        }\n\n        // Forces on nodes due to edge attractions\n        for (var i = 0; i < this.graph.edges.length; i++) {\n            var edge = this.graph.edges[i];\n            this.layoutAttractive(edge);\n        }\n\n        // Move by the given force\n        for (i in this.graph.nodes) {\n            var node = this.graph.nodes[i];\n            var xmove = this.c * node.layoutForceX;\n            var ymove = this.c * node.layoutForceY;\n\n            var max = this.maxVertexMovement;\n            if(xmove > max) xmove = max;\n            if(xmove < -max) xmove = -max;\n            if(ymove > max) ymove = max;\n            if(ymove < -max) ymove = -max;\n\n            node.layoutPosX += xmove;\n            node.layoutPosY += ymove;\n            node.layoutForceX = 0;\n            node.layoutForceY = 0;\n        }\n    },\n\n    layoutRepulsive: function(node1, node2) {\n        if (typeof node1 == 'undefined' || typeof node2 == 'undefined')\n            return;\n        var dx = node2.layoutPosX - node1.layoutPosX;\n        var dy = node2.layoutPosY - node1.layoutPosY;\n        var d2 = dx * dx + dy * dy;\n        if(d2 < 0.01) {\n            dx = 0.1 * Math.random() + 0.1;\n            dy = 0.1 * Math.random() + 0.1;\n            var d2 = dx * dx + dy * dy;\n        }\n        var d = Math.sqrt(d2);\n        if(d < this.maxRepulsiveForceDistance) {\n            var repulsiveForce = this.k * this.k / d;\n            node2.layoutForceX += repulsiveForce * dx / d;\n            node2.layoutForceY += repulsiveForce * dy / d;\n            node1.layoutForceX -= repulsiveForce * dx / d;\n            node1.layoutForceY -= repulsiveForce * dy / d;\n        }\n    },\n\n    layoutAttractive: function(edge) {\n        var node1 = edge.source;\n        var node2 = edge.target;\n\n        var dx = node2.layoutPosX - node1.layoutPosX;\n        var dy = node2.layoutPosY - node1.layoutPosY;\n        var d2 = dx * dx + dy * dy;\n        if(d2 < 0.01) {\n            dx = 0.1 * Math.random() + 0.1;\n            dy = 0.1 * Math.random() + 0.1;\n            var d2 = dx * dx + dy * dy;\n        }\n        var d = Math.sqrt(d2);\n        if(d > this.maxRepulsiveForceDistance) {\n            d = this.maxRepulsiveForceDistance;\n            d2 = d * d;\n        }\n        var attractiveForce = (d2 - this.k * this.k) / this.k;\n        if(edge.attraction == undefined) edge.attraction = 1;\n        attractiveForce *= Math.log(edge.attraction) * 0.5 + 1;\n\n        node2.layoutForceX -= attractiveForce * dx / d;\n        node2.layoutForceY -= attractiveForce * dy / d;\n        node1.layoutForceX += attractiveForce * dx / d;\n        node1.layoutForceY += attractiveForce * dy / d;\n    }\n};\n\nGraph.Layout.Ordered = function(graph, order) {\n    this.graph = graph;\n    this.order = order;\n    this.layout();\n};\nGraph.Layout.Ordered.prototype = {\n    layout: function() {\n        this.layoutPrepare();\n        this.layoutCalcBounds();\n    },\n\n    layoutPrepare: function(order) {\n        for (i in this.graph.nodes) {\n            var node = this.graph.nodes[i];\n            node.layoutPosX = 0;\n            node.layoutPosY = 0;\n        }\n            var counter = 0;\n            for (i in this.order) {\n                var node = this.order[i];\n                node.layoutPosX = counter;\n                node.layoutPosY = Math.random();\n                counter++;\n            }\n    },\n\n    layoutCalcBounds: function() {\n        var minx = Infinity, maxx = -Infinity, miny = Infinity, maxy = -Infinity;\n\n        for (i in this.graph.nodes) {\n            var x = this.graph.nodes[i].layoutPosX;\n            var y = this.graph.nodes[i].layoutPosY;\n\n            if(x > maxx) maxx = x;\n            if(x < minx) minx = x;\n            if(y > maxy) maxy = y;\n            if(y < miny) miny = y;\n        }\n\n        this.graph.layoutMinX = minx;\n        this.graph.layoutMaxX = maxx;\n\n        this.graph.layoutMinY = miny;\n        this.graph.layoutMaxY = maxy;\n    }\n};\n\n\nGraph.Layout.OrderedTree = function(graph, order) {\n    this.graph = graph;\n    this.order = order;\n    this.layout();\n};\n\n/*\n * OrderedTree is like Ordered but assumes there is one root\n * This way we can give non random positions to nodes on the Y-axis\n * it assumes the ordered nodes are of a perfect binary tree\n */\nGraph.Layout.OrderedTree.prototype = {\n    layout: function() {\n        this.layoutPrepare();\n        this.layoutCalcBounds();\n    },\n    \n    layoutPrepare: function(order) {\n        for (i in this.graph.nodes) {\n            var node = this.graph.nodes[i];\n            node.layoutPosX = 0;\n            node.layoutPosY = 0;\n        }\n        //to reverse the order of rendering, we need to find out the\n        //absolute number of levels we have. simple log math applies.\n        var numNodes = this.order.length;\n        var totalLevels = Math.floor(Math.log(numNodes) / Math.log(2));\n        \n        var counter = 1;\n        for (i in this.order) {\n            var node = this.order[i];\n            //rank aka x coordinate \n            var rank = Math.floor(Math.log(counter) / Math.log(2));\n            //file relative to top\n            var file = counter - Math.pow(rank, 2);\n            \n            log('Node ' + node.id + '  #' + counter + ' is at rank ' + rank + ' file ' + file);\n            node.layoutPosX = totalLevels - rank;\n            node.layoutPosY = file;\n            counter++;\n        }\n    },\n    \n    layoutCalcBounds: function() {\n        var minx = Infinity, maxx = -Infinity, miny = Infinity, maxy = -Infinity;\n\n        for (i in this.graph.nodes) {\n            var x = this.graph.nodes[i].layoutPosX;\n            var y = this.graph.nodes[i].layoutPosY;\n            \n            if(x > maxx) maxx = x;\n            if(x < minx) minx = x;\n            if(y > maxy) maxy = y;\n            if(y < miny) miny = y;\n        }\n\n        this.graph.layoutMinX = minx;\n        this.graph.layoutMaxX = maxx;\n\n        this.graph.layoutMinY = miny;\n        this.graph.layoutMaxY = maxy;\n    }\n};\n\n\nGraph.Layout.TournamentTree = function(graph, order) {\n    this.graph = graph;\n    this.order = order;\n    this.layout();\n};\n\n/*\n * TournamentTree looks more like a binary tree\n */\nGraph.Layout.TournamentTree.prototype = {\n    layout: function() {\n        this.layoutPrepare();\n        this.layoutCalcBounds();\n    },\n    \n    layoutPrepare: function(order) {\n        for (i in this.graph.nodes) {\n            var node = this.graph.nodes[i];\n            node.layoutPosX = 0;\n            node.layoutPosY = 0;\n        }\n        //to reverse the order of rendering, we need to find out the\n        //absolute number of levels we have. simple log math applies.\n        var numNodes = this.order.length;\n        var totalLevels = Math.floor(Math.log(numNodes) / Math.log(2));\n        \n        var counter = 1;\n        for (i in this.order) {\n            var node = this.order[i];\n            var depth = Math.floor(Math.log(counter) / Math.log(2));\n            var xpos = counter - Math.pow(depth, 2);\n            var offset = Math.pow(2, totalLevels - depth);\n            var final_x = offset + (counter - Math.pow(2,depth)) * Math.pow(2,(totalLevels - depth)+1);\n            \n            log('Node ' + node.id + '  #' + counter + ' is at depth ' + depth + ' offset ' + offset + ' final_x ' + final_x);\n            node.layoutPosX = final_x;\n            node.layoutPosY = depth;\n            counter++;\n        }\n    },\n    \n    layoutCalcBounds: function() {\n        var minx = Infinity, maxx = -Infinity, miny = Infinity, maxy = -Infinity;\n\n        for (i in this.graph.nodes) {\n            var x = this.graph.nodes[i].layoutPosX;\n            var y = this.graph.nodes[i].layoutPosY;\n            \n            if(x > maxx) maxx = x;\n            if(x < minx) minx = x;\n            if(y > maxy) maxy = y;\n            if(y < miny) miny = y;\n        }\n\n        this.graph.layoutMinX = minx;\n        this.graph.layoutMaxX = maxx;\n\n        this.graph.layoutMinY = miny;\n        this.graph.layoutMaxY = maxy;\n    }\n};\n\n\n\n\n/*\n * usefull JavaScript extensions,\n */\n\nfunction log(a) {console.log&&console.log(a);}\n\n/*\n * Raphael Tooltip Plugin\n * - attaches an element as a tooltip to another element\n *\n * Usage example, adding a rectangle as a tooltip to a circle:\n *\n *      paper.circle(100,100,10).tooltip(paper.rect(0,0,20,30));\n *\n * If you want to use more shapes, you'll have to put them into a set.\n *\n */\nRaphael.el.tooltip = function (tp) {\n    this.tp = tp;\n    this.tp.o = {x: 0, y: 0};\n    this.tp.hide();\n    this.hover(\n        function(event){\n            this.mousemove(function(event){\n                this.tp.translate(event.clientX -\n                                  this.tp.o.x,event.clientY - this.tp.o.y);\n                this.tp.o = {x: event.clientX, y: event.clientY};\n            });\n            this.tp.show().toFront();\n        },\n        function(event){\n            this.tp.hide();\n            this.unmousemove();\n        });\n    return this;\n};\n\n/* For IE */\nif (!Array.prototype.forEach)\n{\n  Array.prototype.forEach = function(fun /*, thisp*/)\n  {\n    var len = this.length;\n    if (typeof fun != \"function\")\n      throw new TypeError();\n\n    var thisp = arguments[1];\n    for (var i = 0; i < len; i++)\n    {\n      if (i in this)\n        fun.call(thisp, this[i], i, this);\n    }\n  };\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":19801}]],"length":19801}
{"contributors":[],"silentsave":true,"ts":1361252634361,"patch":[[{"diffs":[[0,"}\n    );"],[1,"\n    \n    "],[0,"\n\n    va"]],"start1":7825,"start2":7825,"length1":16,"length2":26}]],"length":19811,"saved":false}
{"ts":1361252636948,"patch":[[{"diffs":[[0,"   \n    "],[1,"// "],[0,"\n\n    va"]],"start1":7835,"start2":7835,"length1":16,"length2":19}]],"length":19814,"saved":false}
{"ts":1361252639333,"patch":[[{"diffs":[[0,"\n    // "],[1,"Handle click"],[0,"\n\n    va"]],"start1":7838,"start2":7838,"length1":16,"length2":28}]],"length":19826,"saved":false}
{"ts":1361252641368,"patch":[[{"diffs":[[0,"le click"],[1," events\n    "],[0,"\n\n    va"]],"start1":7850,"start2":7850,"length1":16,"length2":28}]],"length":19838,"saved":false}
{"ts":1361252644030,"patch":[[{"diffs":[[0,"nts\n    "],[1,"// ADDED BY"],[0,"\n\n    va"]],"start1":7862,"start2":7862,"length1":16,"length2":27}]],"length":19849,"saved":false}
{"ts":1361252646575,"patch":[[{"diffs":[[0,"ADDED BY"],[1," GARRETT THIS "],[0,"\n\n    va"]],"start1":7873,"start2":7873,"length1":16,"length2":30}]],"length":19863,"saved":false}
{"ts":1361252650176,"patch":[[{"diffs":[[0,"TT THIS "],[1,"IS NON STANDRAD\n    "],[0,"\n\n    va"]],"start1":7887,"start2":7887,"length1":16,"length2":36}]],"length":19883,"saved":false}
{"ts":1361252654147,"patch":[[{"diffs":[[0,"RAD\n    "],[1,"shape.cli"],[0,"\n\n    va"]],"start1":7907,"start2":7907,"length1":16,"length2":25}]],"length":19892,"saved":false}
{"ts":1361252655665,"patch":[[{"diffs":[[0,"hape.cli"],[1,"ck()"],[0,"\n\n    va"]],"start1":7916,"start2":7916,"length1":16,"length2":20}]],"length":19896,"saved":false}
{"ts":1361252663036,"patch":[[{"diffs":[[0,"e.click("],[-1,")"],[1,"node.onclick);"],[0,"\n\n    va"]],"start1":7919,"start2":7919,"length1":17,"length2":30}]],"length":19909,"saved":false}
{"contributors":[],"silentsave":true,"ts":1361258089830,"patch":[[{"diffs":[[0,"rsor = \""],[-1,"move"],[1,"hand"],[0,"\";\n    }"]],"start1":6740,"start2":6740,"length1":20,"length2":20},{"diffs":[[0,"d\";\n    });\n"],[1,"// REMOVED SHAPE DRAGGING GARRETT\n"],[0,"    shape.dr"]],"start1":6751,"start2":6751,"length1":24,"length2":58},{"diffs":[[0,"target.shape"],[1,");//"],[0,", edge.style"]],"start1":8784,"start2":8784,"length1":24,"length2":28}]],"length":19947,"saved":false}
